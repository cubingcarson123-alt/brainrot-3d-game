<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Brainrot Maze</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: black;
  color: white;
  font-family: sans-serif;
}

#overlay {
  position: fixed;
  inset: 0;
  background: black;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  z-index: 5;
}

#overlay button {
  font-size: 22px;
  padding: 14px 36px;
  cursor: pointer;
}

#meter {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  width: 320px;
  height: 16px;
  border: 2px solid white;
}

#fill {
  height: 100%;
  width: 0%;
  background: red;
}

canvas { display: block; }
</style>
</head>
<body>

<div id="overlay">
  <h1>BRAINROT MAZE</h1>
  <p>Click canvas → move mouse → hold W</p>
  <button id="start">START</button>
</div>

<div id="meter"><div id="fill"></div></div>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
canvas.width = innerWidth;
canvas.height = innerHeight;

addEventListener("resize", () => {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
});

/* ====== MAZE ====== */
const CELL = 140; // BIG corridors
const W = 14, H = 14;
const maze = Array.from({length:H},()=>Array.from({length:W},()=>Math.random()<0.35?1:0));
maze[1][1]=0;

/* ====== PLAYER ====== */
const player = {
  x: CELL*1.5,
  y: CELL*1.5,
  a: 0,
  speed: 2.6
};

/* ====== BRAINROT ====== */
const brain = {
  x: CELL*(W-2),
  y: CELL*(H-2),
  speed: 1.4
};

let locked = false;
let forward = false;

/* ====== INPUT ====== */
canvas.onclick = () => {
  canvas.requestPointerLock();
};

document.addEventListener("pointerlockchange", () => {
  locked = document.pointerLockElement === canvas;
});

document.addEventListener("mousemove", e => {
  if (!locked) return;
  player.a += e.movementX * 0.002;
});

document.addEventListener("keydown", e => {
  if (e.key === "w") forward = true;
});
document.addEventListener("keyup", e => {
  if (e.key === "w") forward = false;
});

/* ====== COLLISION ====== */
function wall(x,y){
  const mx = Math.floor(x/CELL);
  const my = Math.floor(y/CELL);
  return maze[my]?.[mx] === 1;
}
function move(o,dx,dy){
  if(!wall(o.x+dx,o.y)) o.x+=dx;
  if(!wall(o.x,o.y+dy)) o.y+=dy;
}

/* ====== LOOP ====== */
function update(){
  if (locked && forward){
    const dx = Math.cos(player.a)*player.speed;
    const dy = Math.sin(player.a)*player.speed;
    move(player,dx,dy);
  }

  // brainrot chase
  const dx = player.x - brain.x;
  const dy = player.y - brain.y;
  const d = Math.hypot(dx,dy) || 1;
  move(brain, dx/d*brain.speed, dy/d*brain.speed);

  // meter
  const m = Math.max(0,1-d/600);
  document.getElementById("fill").style.width = `${m*100}%`;
}

function draw(){
  ctx.fillStyle="#111";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.save();
  ctx.translate(canvas.width/2,canvas.height/2);
  ctx.rotate(-player.a);
  ctx.translate(-player.x,-player.y);

  ctx.fillStyle="#070707";
  ctx.fillRect(0,0,W*CELL,H*CELL);

  ctx.fillStyle="#333";
  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      if(maze[y][x]) ctx.fillRect(x*CELL,y*CELL,CELL,CELL);
    }
  }

  ctx.fillStyle="red";
  ctx.fillRect(brain.x-20,brain.y-20,40,40);

  ctx.restore();

  ctx.strokeStyle="white";
  ctx.beginPath();
  ctx.moveTo(canvas.width/2-6,canvas.height/2);
  ctx.lineTo(canvas.width/2+6,canvas.height/2);
  ctx.stroke();
}

function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();

/* ====== START ====== */
document.getElementById("start").onclick = ()=>{
  document.getElementById("overlay").remove();
};
</script>
</body>
</html>
