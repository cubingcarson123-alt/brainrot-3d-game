<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>TUNG MAZE</title>
<style>
body{margin:0;overflow:hidden;background:#000;font-family:sans-serif}
#menu,#scare{
 position:fixed;inset:0;
 display:flex;align-items:center;justify-content:center;
 background:#000;color:#fff;z-index:10
}
#menu button{font-size:24px;padding:20px}
#scare{display:none;font-size:80px;background:#fff;color:#000}
#map{position:fixed;top:10px;right:10px;width:200px;height:200px;border:2px solid #fff}
</style>
</head>
<body>

<div id="menu"><button id="start">START</button></div>
<div id="scare">TUNG TUNG TUNG SAHUR</div>
<canvas id="map" width="200" height="200"></canvas>

<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>
<script>
/* ===== STATE ===== */
let running=false;

/* ===== SCENE ===== */
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x111);
const camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,1000);
camera.position.set(0,1.6,80);
const renderer=new THREE.WebGLRenderer();
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

/* ===== LIGHT ===== */
scene.add(new THREE.AmbientLight(0xffffff,1));

/* ===== FLOOR ===== */
const floor=new THREE.Mesh(
 new THREE.PlaneGeometry(300,300),
 new THREE.MeshBasicMaterial({color:0x2a2a2a})
);
floor.rotation.x=-Math.PI/2;
scene.add(floor);

/* ===== WALLS ===== */
const walls=[];
function wall(x,z,w,d){
 const m=new THREE.Mesh(
  new THREE.BoxGeometry(w,4,d),
  new THREE.MeshBasicMaterial({color:0x4aa3ff})
 );
 m.position.set(x,2,z);
 m.userData={w,d};
 scene.add(m); walls.push(m);
}
for(let i=-140;i<=140;i+=20){wall(i,-140,20,3);wall(i,140,20,3);}
for(let i=-120;i<=120;i+=40){wall(-140,i,3,40);wall(140,i,3,40);}
wall(0,0,3,240); wall(-60,40,120,3); wall(60,-40,120,3);

/* ===== EXIT ===== */
const exit=new THREE.Mesh(
 new THREE.BoxGeometry(6,6,6),
 new THREE.MeshBasicMaterial({color:0x00ff00})
);
exit.position.set(120,3,-120);
scene.add(exit);

/* ===== COLLISION ===== */
function hit(p,r=0.6){
 for(const w of walls){
  if(Math.abs(p.x-w.position.x)<w.userData.w/2+r &&
     Math.abs(p.z-w.position.z)<w.userData.d/2+r) return true;
 }
 return false;
}

/* ===== INPUT ===== */
const keys={};
addEventListener("keydown",e=>keys[e.key.toLowerCase()]=true);
addEventListener("keyup",e=>keys[e.key.toLowerCase()]=false);
let yaw=0,vy=0,onGround=true;

/* ===== ENEMY (BODY + LEGS) ===== */
const enemy=new THREE.Group();
const body=new THREE.Mesh(
 new THREE.BoxGeometry(2,3,1),
 new THREE.MeshBasicMaterial({color:0xff3333})
);
body.position.y=2.5;
enemy.add(body);

const legMat=new THREE.MeshBasicMaterial({color:0xaa0000});
const leg1=new THREE.Mesh(new THREE.BoxGeometry(0.6,2,0.6),legMat);
const leg2=leg1.clone();
leg1.position.set(-0.4,1,0);
leg2.position.set(0.4,1,0);
enemy.add(leg1,leg2);

enemy.position.set(100,0,100);
scene.add(enemy);

let enemyDir=new THREE.Vector3(1,0,0);
let chasing=false;

/* ===== MAP ===== */
const map=document.getElementById("map").getContext("2d");
const SCALE=0.7;

/* ===== JUMPSCARE ===== */
const scare=document.getElementById("scare");
function jumpscare(){
 scare.style.display="flex";
 setTimeout(()=>location.reload(),800);
}

/* ===== MENU ===== */
document.getElementById("start").onclick=()=>{
 running=true;
 document.getElementById("menu").style.display="none";
};

/* ===== LOOP ===== */
function animate(){
 requestAnimationFrame(animate);
 if(!running){renderer.render(scene,camera);return;}

 /* LOOK */
 if(keys.arrowleft) yaw+=0.04;
 if(keys.arrowright) yaw-=0.04;
 camera.rotation.y=yaw;

 /* MOVE */
 let v=new THREE.Vector3();
 if(keys.w) v.z-=1;
 if(keys.s) v.z+=1;
 if(keys.a) v.x-=1;
 if(keys.d) v.x+=1;

 if(v.length()){
  v.normalize().applyAxisAngle(new THREE.Vector3(0,1,0),yaw);
  const n=camera.position.clone().add(v.multiplyScalar(0.25));
  if(!hit(n)) camera.position.copy(n);
 }

 /* JUMP */
 if(keys[" "]&&onGround){vy=0.25;onGround=false;}
 vy-=0.015;
 camera.position.y+=vy;
 if(camera.position.y<=1.6){camera.position.y=1.6;vy=0;onGround=true;}

 /* ENEMY AI */
 const toPlayer=camera.position.clone().sub(enemy.position);
 const dist=toPlayer.length();
 chasing=dist<40;

 let move=chasing?toPlayer:enemyDir;
 move.y=0; move.normalize();
 let en=enemy.position.clone().add(move.multiplyScalar(chasing?0.15:0.05));
 if(hit(en)){
  enemyDir.applyAxisAngle(new THREE.Vector3(0,1,0),Math.PI/2);
 }else enemy.position.copy(en);

 enemy.lookAt(camera.position);

 if(dist<2) jumpscare();

 /* EXIT */
 if(camera.position.distanceTo(exit.position)<5){
  alert("ESCAPED");
  location.reload();
 }

 /* MAP */
 map.clearRect(0,0,200,200);
 map.fillStyle="#333"; map.fillRect(0,0,200,200);
 map.fillStyle="#666";
 for(const w of walls)
  map.fillRect(w.position.x*SCALE+100,w.position.z*SCALE+100,w.userData.w*SCALE,w.userData.d*SCALE);
 map.fillStyle="#0f0";
 map.fillRect(camera.position.x*SCALE+100,camera.position.z*SCALE+100,4,4);
 map.fillStyle="#f00";
 map.fillRect(enemy.position.x*SCALE+100,enemy.position.z*SCALE+100,4,4);

 renderer.render(scene,camera);
}
animate();

onresize=()=>{
 camera.aspect=innerWidth/innerHeight;
 camera.updateProjectionMatrix();
 renderer.setSize(innerWidth,innerHeight);
};
</script>
</body>
</html>
