<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Brainrot Maze Chase</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
  body { margin: 0; overflow: hidden; background: black; }
  canvas { display: block; }
  #meter {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 220px;
    height: 20px;
    border: 2px solid white;
    background: #222;
  }
  #fill {
    height: 100%;
    width: 0%;
    background: red;
    transition: width 0.15s;
  }
</style>
</head>

<body>
<div id="meter"><div id="fill"></div></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
/* ================= SETUP ================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const light = new THREE.DirectionalLight(0xffffff, 0.6);
light.position.set(5, 10, 5);
scene.add(light);

/* ================= MAZE ================= */
const GRID = 21;
const CELL = 8;          // WIDE corridors
const maze = Array.from({ length: GRID }, () => Array(GRID).fill(1));

function carve(x, y) {
  maze[y][x] = 0;
  const dirs = [[2,0],[-2,0],[0,2],[0,-2]].sort(() => Math.random() - 0.5);
  for (const [dx, dy] of dirs) {
    const nx = x + dx, ny = y + dy;
    if (nx > 0 && ny > 0 && nx < GRID-1 && ny < GRID-1 && maze[ny][nx]) {
      maze[y + dy/2][x + dx/2] = 0;
      carve(nx, ny);
    }
  }
}
carve(1,1);

const walls = [];
const wallGeo = new THREE.BoxGeometry(CELL, 6, CELL);
const wallMat = new THREE.MeshStandardMaterial({ color: 0x555555 });

for (let z = 0; z < GRID; z++) {
  for (let x = 0; x < GRID; x++) {
    if (maze[z][x]) {
      const w = new THREE.Mesh(wallGeo, wallMat);
      w.position.set((x - GRID/2) * CELL, 3, (z - GRID/2) * CELL);
      scene.add(w);
      walls.push(w);
    }
  }
}

/* ================= FLOOR ================= */
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(1000, 1000),
  new THREE.MeshStandardMaterial({ color: 0x222222 })
);
floor.rotation.x = -Math.PI / 2;
scene.add(floor);

/* ================= PLAYER ================= */
const player = new THREE.Mesh(
  new THREE.BoxGeometry(3, 3, 3),
  new THREE.MeshStandardMaterial({ color: 0x4aa3ff })
);
player.position.set(-(GRID/2-2)*CELL, 1.5, -(GRID/2-2)*CELL);
scene.add(player);

/* ================= ENEMY ================= */
const enemy = new THREE.Mesh(
  new THREE.BoxGeometry(3, 3, 3),
  new THREE.MeshStandardMaterial({ color: 0xff3333 })
);
enemy.position.set((GRID/2-2)*CELL, 1.5, (GRID/2-2)*CELL);
scene.add(enemy);

/* ================= COLLISION ================= */
function blocked(x, z) {
  const gx = Math.floor(x / CELL + GRID / 2);
  const gz = Math.floor(z / CELL + GRID / 2);
  return maze[gz]?.[gx] === 1;
}

/* ================= CONTROLS ================= */
const keys = {};
addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

/* ================= GAME ================= */
const playerSpeed = 0.25;
const enemySpeed  = 0.18;
const fill = document.getElementById("fill");

function animate() {
  requestAnimationFrame(animate);

  let px = player.position.x;
  let pz = player.position.z;

  if (keys.w) pz -= playerSpeed;
  if (keys.s) pz += playerSpeed;
  if (keys.a) px -= playerSpeed;
  if (keys.d) px += playerSpeed;

  if (!blocked(px, pz)) {
    player.position.x = px;
    player.position.z = pz;
  }

  // ENEMY CHASE (WALL-AWARE)
  const dx = player.position.x - enemy.position.x;
  const dz = player.position.z - enemy.position.z;
  const dist = Math.hypot(dx, dz);

  let ex = enemy.position.x + (dx / dist) * enemySpeed;
  let ez = enemy.position.z + (dz / dist) * enemySpeed;

  if (!blocked(ex, ez)) {
    enemy.position.x = ex;
    enemy.position.z = ez;
  }

  // BRAINROT METER
  const danger = Math.max(0, 1 - dist / 60);
  fill.style.width = `${danger * 100}%`;

  // CAMERA (PLAYER POV-ish)
  camera.position.set(
    player.position.x,
    6,
    player.position.z + 10
  );
  camera.lookAt(player.position);

  renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>
