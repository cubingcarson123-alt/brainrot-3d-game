<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Brainrot Maze</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #000;
    font-family: Arial, sans-serif;
    color: white;
  }

  #menu {
    position: fixed;
    inset: 0;
    background: black;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    z-index: 10;
  }

  #menu h1 {
    margin-bottom: 20px;
    font-size: 40px;
  }

  #menu button {
    font-size: 20px;
    padding: 12px 30px;
    cursor: pointer;
  }

  #meter {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 300px;
    height: 18px;
    border: 2px solid white;
  }

  #meterFill {
    height: 100%;
    width: 0%;
    background: red;
  }

  canvas {
    display: block;
  }
</style>
</head>
<body>

<div id="menu">
  <h1>BRAINROT MAZE</h1>
  <button id="startBtn">CLICK TO START</button>
</div>

<div id="meter">
  <div id="meterFill"></div>
</div>

<canvas id="game"></canvas>

<script>
/* ===================== SETUP ===================== */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = innerWidth;
canvas.height = innerHeight;

addEventListener("resize", () => {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
});

let started = false;

/* ===================== MAZE ===================== */
const CELL = 120; // BIG corridors
const MAZE_W = 15;
const MAZE_H = 15;

const maze = Array.from({ length: MAZE_H }, () =>
  Array.from({ length: MAZE_W }, () => Math.random() < 0.35 ? 1 : 0)
);
maze[1][1] = 0;

/* ===================== PLAYER ===================== */
const player = {
  x: CELL * 1.5,
  y: CELL * 1.5,
  angle: 0,
  speed: 2.5,
  radius: 18
};

/* ===================== ENEMY (BRAINROT) ===================== */
const brainrot = {
  x: CELL * (MAZE_W - 2),
  y: CELL * (MAZE_H - 2),
  speed: 1.2
};

/* ===================== INPUT ===================== */
let mouseLocked = false;
let forward = false;

document.addEventListener("mousemove", e => {
  if (!mouseLocked) return;
  player.angle += e.movementX * 0.002;
});

document.addEventListener("keydown", e => {
  if (e.key === "w") forward = true;
});

document.addEventListener("keyup", e => {
  if (e.key === "w") forward = false;
});

/* ===================== COLLISION ===================== */
function wallAt(x, y) {
  const mx = Math.floor(x / CELL);
  const my = Math.floor(y / CELL);
  return maze[my]?.[mx] === 1;
}

function moveEntity(ent, dx, dy) {
  if (!wallAt(ent.x + dx, ent.y)) ent.x += dx;
  if (!wallAt(ent.x, ent.y + dy)) ent.y += dy;
}

/* ===================== GAME LOOP ===================== */
function update() {
  if (!started) return;

  // Player move
  if (forward) {
    const dx = Math.cos(player.angle) * player.speed;
    const dy = Math.sin(player.angle) * player.speed;
    moveEntity(player, dx, dy);
  }

  // Enemy simple roaming + chase
  const dx = player.x - brainrot.x;
  const dy = player.y - brainrot.y;
  const dist = Math.hypot(dx, dy);

  const ex = (dx / dist) * brainrot.speed;
  const ey = (dy / dist) * brainrot.speed;

  moveEntity(brainrot, ex, ey);

  // Meter
  const meter = Math.max(0, 1 - dist / 600);
  document.getElementById("meterFill").style.width = `${meter * 100}%`;
}

/* ===================== RENDER ===================== */
function draw() {
  ctx.fillStyle = "#111";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Fake 3D top-down render
  ctx.save();
  ctx.translate(canvas.width / 2, canvas.height / 2);
  ctx.rotate(-player.angle);
  ctx.translate(-player.x, -player.y);

  // Floor
  ctx.fillStyle = "#080808";
  ctx.fillRect(0, 0, MAZE_W * CELL, MAZE_H * CELL);

  // Walls
  ctx.fillStyle = "#333";
  for (let y = 0; y < MAZE_H; y++) {
    for (let x = 0; x < MAZE_W; x++) {
      if (maze[y][x]) {
        ctx.fillRect(x * CELL, y * CELL, CELL, CELL);
      }
    }
  }

  // Brainrot
  ctx.fillStyle = "red";
  ctx.fillRect(brainrot.x - 20, brainrot.y - 20, 40, 40);

  ctx.restore();

  // Crosshair
  ctx.strokeStyle = "white";
  ctx.beginPath();
  ctx.moveTo(canvas.width/2 - 5, canvas.height/2);
  ctx.lineTo(canvas.width/2 + 5, canvas.height/2);
  ctx.stroke();
}

/* ===================== LOOP ===================== */
function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();

/* ===================== START ===================== */
document.getElementById("startBtn").onclick = () => {
  document.getElementById("menu").style.display = "none";
  canvas.requestPointerLock();
};

document.addEventListener("pointerlockchange", () => {
  mouseLocked = document.pointerLockElement === canvas;
  started = mouseLocked;
});
</script>
</body>
</html>
