<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Maze Horror</title>
<style>
html,body{margin:0;overflow:hidden;background:black;font-family:monospace}
canvas{display:block}
#map{
  position:fixed;
  right:10px;
  bottom:10px;
  width:260px;
  height:260px;
  border:2px solid white;
  background:#111;
}
#hint{
  position:fixed;
  top:10px;
  left:50%;
  transform:translateX(-50%);
  color:white;
}
</style>
</head>
<body>

<div id="hint">Click → Mouse Lock • W to move</div>
<canvas id="game"></canvas>
<canvas id="map"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const map = document.getElementById("map");
const mctx = map.getContext("2d");

canvas.width = innerWidth;
canvas.height = innerHeight;
onresize = () => { canvas.width=innerWidth; canvas.height=innerHeight; };

const TILE = 120;

/* BIG MAZE */
const MAZE = [
"########################",
"#.............#........#",
"#.######.#####.#.####..#",
"#.#....#.....#.#.#..#..#",
"#.#.##.######.#.#.#.##.#",
"#.#.#........#...#....#",
"#.#.#.###########.######",
"#...#.................E#",
"###.####################",
"#......................#",
"########################"
];

function isWall(x,y){ return MAZE[y]?.[x]==="#"; }

/* PLAYER */
const player={
  x:TILE*1.5,
  y:TILE*1.5,
  a:0,
  speed:3
};

let forward=false;

/* CPU (TUNG TUNG SAHUR) */
const tung={
  x:TILE*14.5,
  y:TILE*6.5,
  dir:Math.random()*Math.PI*2,
  speed:1.1
};

/* INPUT */
onclick=()=>canvas.requestPointerLock();
onkeydown=e=>{ if(e.key==="w") forward=true; };
onkeyup=e=>{ if(e.key==="w") forward=false; };

onmousemove=e=>{
  if(document.pointerLockElement){
    player.a+=e.movementX*0.0015;
  }
};

/* COLLISION */
function canMove(x,y){
  return !isWall(Math.floor(x/TILE),Math.floor(y/TILE));
}

/* UPDATE */
function update(){
  if(forward){
    let nx=player.x+Math.cos(player.a)*player.speed;
    let ny=player.y+Math.sin(player.a)*player.speed;
    if(canMove(nx,ny)){ player.x=nx; player.y=ny; }
  }

  let cx=tung.x+Math.cos(tung.dir)*tung.speed;
  let cy=tung.y+Math.sin(tung.dir)*tung.speed;
  if(canMove(cx,cy)){ tung.x=cx; tung.y=cy; }
  else tung.dir=Math.random()*Math.PI*2;
}

/* DRAW WORLD */
function drawMaze(){
  for(let y=0;y<MAZE.length;y++){
    for(let x=0;x<MAZE[y].length;x++){
      if(MAZE[y][x]==="#"){
        ctx.fillStyle="#333";
        ctx.fillRect(
          x*TILE-player.x+canvas.width/2,
          y*TILE-player.y+canvas.height/2,
          TILE,TILE
        );
      }
    }
  }
}

/* PSEUDO-3D ENTITY */
function drawEntity(ent,color){
  const dx=ent.x-player.x;
  const dy=ent.y-player.y;
  const dist=Math.hypot(dx,dy);

  const size=Math.max(20,1200/dist);
  const sx=canvas.width/2+dx;
  const sy=canvas.height/2+dy-size/2;

  ctx.fillStyle=color;
  ctx.beginPath();
  ctx.roundRect(sx-size/2,sy,size,size*1.8,20);
  ctx.fill();

  // eyes (makes it creepy & 3D)
  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(sx-size/6,sy+size/3, size/10,0,Math.PI*2);
  ctx.arc(sx+size/6,sy+size/3, size/10,0,Math.PI*2);
  ctx.fill();
}

/* MINIMAP (FULL MAZE) */
function drawMap(){
  mctx.clearRect(0,0,map.width,map.height);
  const scale=Math.min(
    map.width/(MAZE[0].length*TILE),
    map.height/(MAZE.length*TILE)
  );

  for(let y=0;y<MAZE.length;y++){
    for(let x=0;x<MAZE[y].length;x++){
      if(MAZE[y][x]==="#"){
        mctx.fillStyle="#555";
        mctx.fillRect(x*TILE*scale,y*TILE*scale,TILE*scale,TILE*scale);
      }
      if(MAZE[y][x]==="E"){
        mctx.fillStyle="lime";
        mctx.fillRect(x*TILE*scale,y*TILE*scale,TILE*scale,TILE*scale);
      }
    }
  }

  mctx.fillStyle="cyan";
  mctx.fillRect(player.x*scale-4,player.y*scale-4,8,8);

  mctx.fillStyle="red";
  mctx.fillRect(tung.x*scale-4,tung.y*scale-4,8,8);
}

/* LOOP */
function loop(){
  ctx.fillStyle="black";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  update();
  drawMaze();
  drawEntity(tung,"#8b4513"); // TUNG TUNG SAHUR
  drawMap();

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
