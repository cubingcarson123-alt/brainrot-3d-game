<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Tung Tung Maze 3D</title>
<style>
body { margin:0; overflow:hidden; background:#000; font-family:sans-serif }
#menu {
  position:fixed; inset:0; background:#000;
  display:flex; align-items:center; justify-content:center;
  color:white; flex-direction:column; z-index:10;
}
#bar {
  position:fixed; bottom:20px; left:50%;
  transform:translateX(-50%);
  width:300px; height:14px;
  background:#333; border:2px solid #fff;
}
#barInner {
  height:100%; width:0%; background:red;
}
#map {
  position:fixed; top:10px; right:10px;
  width:150px; height:150px;
  background:#111; border:2px solid #fff;
}
#jumpscare {
  position:fixed; inset:0;
  background:black; display:none;
  align-items:center; justify-content:center;
  z-index:20;
}
#eye {
  width:200px; height:200px;
  background:white; border-radius:50%;
  position:relative;
}
#eye::after {
  content:"";
  position:absolute; inset:60px;
  background:black; border-radius:50%;
}
</style>
</head>
<body>

<div id="menu">
  <h1>TUNG TUNG MAZE</h1>
  <button onclick="start()">START</button>
</div>

<div id="bar"><div id="barInner"></div></div>
<canvas id="map"></canvas>

<div id="jumpscare"><div id="eye"></div></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>
<script>
/* ---------- SCENE ---------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(1,1.6,1);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ---------- LIGHT ---------- */
scene.add(new THREE.AmbientLight(0xffffff,0.5));
const sun = new THREE.DirectionalLight(0xffffff,1);
sun.position.set(5,10,5);
scene.add(sun);

/* ---------- FLOOR ---------- */
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(100,100),
  new THREE.MeshStandardMaterial({color:0x4444ff})
);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

/* ---------- MAZE ---------- */
const maze = [
"###############",
"#S     #      #",
"# ### ### #### #",
"#   #     #    #",
"### ##### # ####",
"#       # #    #",
"# ##### # #### #",
"#     # #      #",
"# ### # ####### #",
"#   # #       E#",
"###############"
];

const walls=[];
const size=2;

maze.forEach((row,z)=>{
  [...row].forEach((cell,x)=>{
    if(cell==="#"){
      const w=new THREE.Mesh(
        new THREE.BoxGeometry(size,2,size),
        new THREE.MeshStandardMaterial({color:0x7faaff})
      );
      w.position.set(x*size,1,z*size);
      scene.add(w); walls.push(w);
    }
    if(cell==="S") camera.position.set(x*size,1.6,z*size);
  });
});

/* ---------- COLLISION ---------- */
function hit(pos){
  return walls.some(w=>
    Math.abs(pos.x-w.position.x)<1 &&
    Math.abs(pos.z-w.position.z)<1
  );
}

/* ---------- PLAYER ---------- */
let velY=0, onGround=true;
let yaw=0, pitch=0;
const keys={};

addEventListener("keydown",e=>keys[e.key.toLowerCase()]=true);
addEventListener("keyup",e=>keys[e.key.toLowerCase()]=false);

/* ---------- ENEMY ---------- */
const enemy = new THREE.Group();

// body
const body=new THREE.Mesh(
  new THREE.BoxGeometry(1,1.5,1),
  new THREE.MeshStandardMaterial({color:0xffffff})
);
body.position.y=1;
enemy.add(body);

// legs
for(let i=-0.3;i<=0.3;i+=0.6){
  const leg=new THREE.Mesh(
    new THREE.BoxGeometry(0.2,1,0.2),
    new THREE.MeshStandardMaterial({color:0xffffff})
  );
  leg.position.set(i,0.5,0);
  enemy.add(leg);
}

// face
const eye1=new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({color:0x000000}));
eye1.position.set(-0.2,1.2,0.51);
const eye2=eye1.clone(); eye2.position.x=0.2;
enemy.add(eye1,eye2);

enemy.position.set(10,0,10);
scene.add(enemy);

let enemyDir=new THREE.Vector3(1,0,0);

/* ---------- MAP ---------- */
const map=document.getElementById("map");
const mctx=map.getContext("2d");
function drawMap(){
  mctx.clearRect(0,0,150,150);
  maze.forEach((r,z)=>{
    [...r].forEach((c,x)=>{
      if(c==="#"){ mctx.fillStyle="#555"; mctx.fillRect(x*10,z*10,10,10); }
    });
  });
  mctx.fillStyle="green";
  mctx.fillRect(camera.position.x/2*5,camera.position.z/2*5,4,4);
  mctx.fillStyle="red";
  mctx.fillRect(enemy.position.x/2*5,enemy.position.z/2*5,4,4);
}

/* ---------- GAME LOOP ---------- */
function animate(){
  requestAnimationFrame(animate);

  // look
  if(keys["arrowleft"]) yaw+=0.03;
  if(keys["arrowright"]) yaw-=0.03;
  camera.rotation.y=yaw;

  // move
  const dir=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
  let next=camera.position.clone();
  if(keys["w"]) next.add(dir.clone().multiplyScalar(0.1));
  if(keys["s"]) next.add(dir.clone().multiplyScalar(-0.1));
  if(!hit(next)) camera.position.copy(next);

  // jump
  if(keys[" "] && onGround){ velY=0.25; onGround=false; }
  velY-=0.01;
  camera.position.y+=velY;
  if(camera.position.y<1.6){ camera.position.y=1.6; velY=0; onGround=true; }

  // enemy AI
  const dist=camera.position.distanceTo(enemy.position);
  let move=enemyDir.clone();
  if(dist<8) move=camera.position.clone().sub(enemy.position).normalize();
  const enext=enemy.position.clone().add(move.multiplyScalar(0.05));
  if(!hit(enext)) enemy.position.copy(enext);
  else enemyDir.x*=-1;

  // proximity bar
  document.getElementById("barInner").style.width=Math.max(0,100-(dist*10))+"%";

  // jumpscare
  if(dist<1){
    document.getElementById("jumpscare").style.display="flex";
    setTimeout(()=>location.reload(),1000);
  }

  drawMap();
  renderer.render(scene,camera);
}
animate();

onresize=()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
};

function start(){
  document.getElementById("menu").style.display="none";
}
</script>
</body>
</html>
