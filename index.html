<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Hard Maze Chase</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body { margin: 0; overflow: hidden; background: black; }
  canvas { display: block; }
  #ui {
    position: fixed;
    top: 10px;
    left: 10px;
    color: white;
    font-family: monospace;
    z-index: 10;
  }
</style>
</head>
<body>
<div id="ui">WASD = move</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
/* =========================
   BASIC SETUP
========================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.set(0, 6, 10);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* =========================
   LIGHTING
========================= */
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const light = new THREE.DirectionalLight(0xffffff, 0.6);
light.position.set(5, 10, 5);
scene.add(light);

/* =========================
   MAZE SETTINGS
========================= */
const GRID = 21;
const CELL = 4;
const maze = Array.from({ length: GRID }, () => Array(GRID).fill(1));

function carve(x, y) {
  maze[y][x] = 0;
  const dirs = [[2,0],[-2,0],[0,2],[0,-2]].sort(() => Math.random() - 0.5);
  for (const [dx, dy] of dirs) {
    const nx = x + dx, ny = y + dy;
    if (nx > 0 && ny > 0 && nx < GRID-1 && ny < GRID-1 && maze[ny][nx]) {
      maze[y + dy/2][x + dx/2] = 0;
      carve(nx, ny);
    }
  }
}
carve(1,1);

/* =========================
   BUILD MAZE
========================= */
const wallGeo = new THREE.BoxGeometry(CELL, 4, CELL);
const wallMat = new THREE.MeshStandardMaterial({ color: 0x555555 });

const walls = [];
for (let z = 0; z < GRID; z++) {
  for (let x = 0; x < GRID; x++) {
    if (maze[z][x]) {
      const wall = new THREE.Mesh(wallGeo, wallMat);
      wall.position.set(
        (x - GRID/2) * CELL,
        2,
        (z - GRID/2) * CELL
      );
      scene.add(wall);
      walls.push(wall);
    }
  }
}

/* =========================
   FLOOR
========================= */
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(500, 500),
  new THREE.MeshStandardMaterial({ color: 0x222222 })
);
floor.rotation.x = -Math.PI / 2;
scene.add(floor);

/* =========================
   PLAYER
========================= */
const player = new THREE.Mesh(
  new THREE.BoxGeometry(2, 2, 2),
  new THREE.MeshStandardMaterial({ color: 0x4aa3ff })
);
player.position.set(-(GRID/2-2)*CELL, 1, -(GRID/2-2)*CELL);
scene.add(player);

/* =========================
   ENEMY (SLOWER)
========================= */
const enemy = new THREE.Mesh(
  new THREE.BoxGeometry(2.2, 2.2, 2.2),
  new THREE.MeshStandardMaterial({ color: 0xff4444 })
);
enemy.position.set((GRID/2-2)*CELL, 1, (GRID/2-2)*CELL);
scene.add(enemy);

/* =========================
   CONTROLS
========================= */
const keys = {};
addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

function blocked(x, z) {
  const gx = Math.floor(x / CELL + GRID / 2);
  const gz = Math.floor(z / CELL + GRID / 2);
  return maze[gz]?.[gx] === 1;
}

/* =========================
   GAME LOOP
========================= */
const playerSpeed = 0.15;
const enemySpeed = 0.09;

function animate() {
  requestAnimationFrame(animate);

  let px = player.position.x;
  let pz = player.position.z;

  if (keys.w) pz -= playerSpeed;
  if (keys.s) pz += playerSpeed;
  if (keys.a) px -= playerSpeed;
  if (keys.d) px += playerSpeed;

  if (!blocked(px, pz)) {
    player.position.x = px;
    player.position.z = pz;
  }

  // Enemy chase with corner escape
  const dx = player.position.x - enemy.position.x;
  const dz = player.position.z - enemy.position.z;
  const len = Math.hypot(dx, dz) || 1;

  const ex = enemy.position.x + dx / len * enemySpeed;
  const ez = enemy.position.z + dz / len * enemySpeed;

  if (!blocked(ex, ez)) {
    enemy.position.x = ex;
    enemy.position.z = ez;
  } else {
    enemy.position.x += (Math.random() - 0.5) * 0.2;
    enemy.position.z += (Math.random() - 0.5) * 0.2;
  }

  camera.position.x = player.position.x;
  camera.position.z = player.position.z + 10;
  camera.lookAt(player.position);

  renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>
