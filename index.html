<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Maze Horror – 3D</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html, body { margin:0; padding:0; overflow:hidden; background:#000; font-family:system-ui, sans-serif; }
  #hud { position:fixed; inset:0; pointer-events:none; }
  #hint { position:absolute; top:12px; left:50%; transform:translateX(-50%); color:#bbb; font-size:12px; }
  #meterWrap { position:absolute; bottom:20px; left:50%; transform:translateX(-50%); width:220px; height:12px; border:1px solid #777; }
  #meter { height:100%; width:0%; background:#c00; }
  #map { position:absolute; right:12px; bottom:12px; width:180px; height:180px; background:#111; border:1px solid #555; }
  #menu { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:radial-gradient(#111,#000); color:#eee; }
  #menu button { padding:12px 18px; font-size:16px; cursor:pointer; }
</style>
</head>
<body>
<div id="menu"><button id="startBtn">Click to Start</button></div>
<canvas id="c"></canvas>
<div id="hud">
  <div id="hint">Mouse = look • W = move forward</div>
  <div id="meterWrap"><div id="meter"></div></div>
  <canvas id="map" width="180" height="180"></canvas>
</div>

<script type="module">
// ===== THREE.JS SETUP =====
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x000000);

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x000000, 4, 14);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 50);

const light = new THREE.DirectionalLight(0xffffff, 0.9);
light.position.set(3,6,3);
scene.add(light, new THREE.AmbientLight(0x404040));

// ===== MAZE (GUARANTEED SOLVABLE) =====
// 0 = empty, 1 = wall
const maze = [
  '111111111111111',
  '100000000001001',
  '101111011101101',
  '101000010001001',
  '101011110111101',
  '101010000100001',
  '101011011101101',
  '100000010000001',
  '101111011111101',
  '101000000000001',
  '101011111111101',
  '100010000000001',
  '101110111111101',
  '100000000000003',
  '111111111111111'
].map(r=>r.split('').map(n=>+n));

const TILE = 1;
const wallMat = new THREE.MeshStandardMaterial({ color:0x333333 });
const floorMat = new THREE.MeshStandardMaterial({ color:0x111111 });

// Floor
const floor = new THREE.Mesh(new THREE.PlaneGeometry(50,50), floorMat);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

// Build walls
for (let z=0; z<maze.length; z++){
  for (let x=0; x<maze[z].length; x++){
    if (maze[z][x] === 1){
      const w = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), wallMat);
      w.position.set(x*TILE, 0.5, z*TILE);
      scene.add(w);
    }
  }
}

// ===== PLAYER =====
const player = { x:1.5, z:1.5, rot:0, speed:0.045 };
camera.position.set(player.x, 0.6, player.z);

// ===== CPU (ROAMING, NOT CHASING YET) =====
const cpuGeo = new THREE.BoxGeometry(0.5,0.8,0.5);
const cpuMat = new THREE.MeshStandardMaterial({ color:0xaa2222 });
const cpu = new THREE.Mesh(cpuGeo, cpuMat);
let cpuPos = { x:13.5, z:13.5 };
cpu.position.set(cpuPos.x, 0.4, cpuPos.z);
scene.add(cpu);

let cpuDir = Math.random()*Math.PI*2;

// ===== POINTER LOCK =====
let locked = false;
const menu = document.getElementById('menu');
const startBtn = document.getElementById('startBtn');
startBtn.onclick = () => {
  canvas.requestPointerLock();
};

document.addEventListener('pointerlockchange', ()=>{
  locked = document.pointerLockElement === canvas;
  menu.style.display = locked ? 'none' : 'flex';
});

let mouseX = 0;
document.addEventListener('mousemove', e=>{ if(locked) mouseX += e.movementX * 0.002; });

// ===== INPUT =====
const keys = {};
addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);

function wallAt(x,z){
  const gx = Math.floor(x);
  const gz = Math.floor(z);
  return maze[gz]?.[gx] === 1;
}

// ===== MINIMAP =====
const mapC = document.getElementById('map');
const mctx = mapC.getContext('2d');

function drawMap(){
  mctx.clearRect(0,0,180,180);
  const s = 180/maze.length;
  for(let z=0; z<maze.length; z++){
    for(let x=0; x<maze[z].length; x++){
      if(maze[z][x]===1){ mctx.fillStyle='#444'; mctx.fillRect(x*s,z*s,s,s); }
      if(maze[z][x]===3){ mctx.fillStyle='#0f0'; mctx.fillRect(x*s,z*s,s,s); }
    }
  }
  mctx.fillStyle='#0ff'; mctx.fillRect(player.x*s-2, player.z*s-2,4,4);
  mctx.fillStyle='#f00'; mctx.fillRect(cpuPos.x*s-2, cpuPos.z*s-2,4,4);
}

// ===== JUMPSCARE (GREEN) =====
const audio = new Audio('https://actions.google.com/sounds/v1/horror/horror_hit.ogg');

function jumpscare(){
  audio.currentTime = 0; audio.play();
  renderer.setClearColor(0xffffff);
  setTimeout(()=>renderer.setClearColor(0x000000),120);
  player.x=1.5; player.z=1.5; cpuPos={x:13.5,z:13.5};
}

// ===== LOOP =====
const meter = document.getElementById('meter');

function tick(){
  requestAnimationFrame(tick);

  // camera
  player.rot -= mouseX; mouseX=0;
  camera.rotation.y = player.rot;

  // move
  if(keys['w']){
    const nx = player.x + Math.sin(player.rot)*player.speed;
    const nz = player.z + Math.cos(player.rot)*player.speed;
    if(!wallAt(nx, nz)){ player.x=nx; player.z=nz; }
  }
  camera.position.set(player.x,0.6,player.z);

  // CPU roam
  const nx = cpuPos.x + Math.sin(cpuDir)*0.015;
  const nz = cpuPos.z + Math.cos(cpuDir)*0.015;
  if(wallAt(nx,nz)) cpuDir += Math.PI/2; else { cpuPos.x=nx; cpuPos.z=nz; }
  cpu.position.set(cpuPos.x,0.4,cpuPos.z);

  // suspense meter
  const dx = cpuPos.x-player.x;
  const dz = cpuPos.z-player.z;
  const d = Math.hypot(dx,dz);
  const p = Math.max(0, 1-d/6);
  meter.style.width = (p*100)+'%';
  if(d < 0.6) jumpscare();

  drawMap();
  renderer.render(scene,camera);
}

tick();
addEventListener('resize', ()=>{
  renderer.setSize(innerWidth,innerHeight);
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
});
</script>
</body>
</html>
