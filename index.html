<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Tung Tung Maze FIXED</title>
<style>
body { margin:0; overflow:hidden; background:#000; }
#bar {
  position:fixed; bottom:20px; left:50%;
  transform:translateX(-50%);
  width:300px; height:14px;
  border:2px solid white; background:#333;
}
#barInner { height:100%; width:0%; background:red; }
#map {
  position:fixed; top:10px; right:10px;
  width:160px; height:160px;
  background:#111; border:2px solid white;
}
#jumpscare {
  position:fixed; inset:0; background:black;
  display:none; align-items:center; justify-content:center;
  z-index:10;
}
.eye {
  width:120px; height:120px; background:white;
  border-radius:50%; margin:20px; animation:pulse 0.3s infinite;
}
.eye::after {
  content:""; position:absolute; inset:40px;
  background:black; border-radius:50%;
}
@keyframes pulse {
  0%{transform:scale(1)}
  100%{transform:scale(1.2)}
}
</style>
</head>
<body>

<div id="bar"><div id="barInner"></div></div>
<canvas id="map"></canvas>
<div id="jumpscare"><div class="eye"></div><div class="eye"></div></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>
<script>
/* ---------- BASIC SETUP ---------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(3,1.6,3);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff,0.6));
const sun=new THREE.DirectionalLight(0xffffff,0.8);
sun.position.set(10,20,10);
scene.add(sun);

/* ---------- FLOOR ---------- */
const floor=new THREE.Mesh(
  new THREE.PlaneGeometry(200,200),
  new THREE.MeshStandardMaterial({color:0x3355ff})
);
floor.rotation.x=-Math.PI/2;
scene.add(floor);

/* ---------- MAZE ---------- */
const CELL=4; // WIDER corridors
const maze=[
"###############",
"#S     #      #",
"# ### ### #### #",
"#   #     #    #",
"### ##### # ####",
"#       # #    #",
"# ##### # #### #",
"#     # #      #",
"# ### # ####### #",
"#   # #       E#",
"###############"
];

const walls=[];
maze.forEach((row,z)=>{
  [...row].forEach((c,x)=>{
    if(c==="#"){
      const w=new THREE.Mesh(
        new THREE.BoxGeometry(CELL,3,CELL),
        new THREE.MeshStandardMaterial({color:0x7faaff})
      );
      w.position.set(x*CELL,1.5,z*CELL);
      scene.add(w);
      walls.push(w);
    }
    if(c==="S") camera.position.set(x*CELL,1.6,z*CELL);
  });
});

/* ---------- COLLISION (REAL) ---------- */
const PLAYER_RADIUS=0.6;
function blocked(pos){
  return walls.some(w=>{
    const dx=Math.abs(pos.x-w.position.x);
    const dz=Math.abs(pos.z-w.position.z);
    return dx < (CELL/2 + PLAYER_RADIUS) &&
           dz < (CELL/2 + PLAYER_RADIUS);
  });
}

/* ---------- CONTROLS ---------- */
let yaw=0, velY=0, onGround=true;
const keys={};
addEventListener("keydown",e=>keys[e.key.toLowerCase()]=true);
addEventListener("keyup",e=>keys[e.key.toLowerCase()]=false);

/* ---------- ENEMY ---------- */
const enemy=new THREE.Group();
const body=new THREE.Mesh(
  new THREE.BoxGeometry(1.2,1.8,1.2),
  new THREE.MeshStandardMaterial({color:0xffffff})
);
body.position.y=1;
enemy.add(body);

// legs
for(let i=-0.3;i<=0.3;i+=0.6){
  const leg=new THREE.Mesh(
    new THREE.BoxGeometry(0.3,1,0.3),
    new THREE.MeshStandardMaterial({color:0xffffff})
  );
  leg.position.set(i,0.5,0);
  enemy.add(leg);
}

// face
const eyeL=new THREE.Mesh(new THREE.SphereGeometry(0.12), new THREE.MeshBasicMaterial({color:0x000000}));
eyeL.position.set(-0.25,1.3,0.61);
const eyeR=eyeL.clone(); eyeR.position.x=0.25;
enemy.add(eyeL,eyeR);

enemy.position.set(10*CELL,0,8*CELL);
scene.add(enemy);

let roamDir=new THREE.Vector3(1,0,0);

/* ---------- MAP ---------- */
const map=document.getElementById("map");
const ctx=map.getContext("2d");
function drawMap(){
  ctx.clearRect(0,0,160,160);
  maze.forEach((r,z)=>{
    [...r].forEach((c,x)=>{
      if(c==="#"){
        ctx.fillStyle="#555";
        ctx.fillRect(x*10,z*10,10,10);
      }
    });
  });
  ctx.fillStyle="green";
  ctx.fillRect(camera.position.x/CELL*10,camera.position.z/CELL*10,4,4);
  ctx.fillStyle="red";
  ctx.fillRect(enemy.position.x/CELL*10,enemy.position.z/CELL*10,4,4);
}

/* ---------- LOOP ---------- */
function animate(){
  requestAnimationFrame(animate);

  // look
  if(keys["arrowleft"]) yaw+=0.04;
  if(keys["arrowright"]) yaw-=0.04;
  camera.rotation.y=yaw;

  // movement (FIXED forward)
  const forward=new THREE.Vector3(-Math.sin(yaw),0,-Math.cos(yaw));
  let next=camera.position.clone();
  if(keys["w"]) next.add(forward.clone().multiplyScalar(0.12));
  if(keys["s"]) next.add(forward.clone().multiplyScalar(-0.12));
  if(!blocked(next)) camera.position.copy(next);

  // jump
  if(keys[" "] && onGround){ velY=0.28; onGround=false; }
  velY-=0.015;
  camera.position.y+=velY;
  if(camera.position.y<1.6){ camera.position.y=1.6; velY=0; onGround=true; }

  // enemy AI
  const dist=camera.position.distanceTo(enemy.position);
  let dir=roamDir.clone();
  if(dist<10) dir=camera.position.clone().sub(enemy.position).normalize();
  const enext=enemy.position.clone().add(dir.multiplyScalar(0.06));
  if(!blocked(enext)) enemy.position.copy(enext);
  else roamDir.x*=-1;

  // proximity bar
  document.getElementById("barInner").style.width=Math.max(0,100-(dist*8))+"%";

  // jumpscare (GUARANTEED)
  if(dist<1.2){
    document.getElementById("jumpscare").style.display="flex";
    setTimeout(()=>location.reload(),900);
  }

  drawMap();
  renderer.render(scene,camera);
}
animate();

onresize=()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
};
</script>
</body>
</html>
