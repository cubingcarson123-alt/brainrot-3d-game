<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Brainrot Maze (Fixed AI)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body { margin:0; overflow:hidden; background:black; }
#ui {
  position:fixed;
  top:10px;
  left:10px;
  color:white;
  font-family:monospace;
}
#meter {
  width:240px;
  height:14px;
  background:#333;
  border:1px solid #777;
  margin-top:6px;
}
#fill { height:100%; width:0%; background:lime; }
</style>
</head>
<body>

<div id="ui">
Brainrot Proximity
<div id="meter"><div id="fill"></div></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
/* ================= SETUP ================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

addEventListener('resize',()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

scene.add(new THREE.AmbientLight(0xffffff,0.7));
const sun = new THREE.DirectionalLight(0xffffff,0.6);
sun.position.set(10,15,5);
scene.add(sun);

/* ================= MAZE ================= */
const GRID = 21;
const CELL = 10;
const WALL_H = 5;

const maze = Array.from({length:GRID},()=>Array(GRID).fill(1));

function carve(x,y){
  maze[y][x]=0;
  [[2,0],[-2,0],[0,2],[0,-2]].sort(()=>Math.random()-0.5)
  .forEach(([dx,dy])=>{
    const nx=x+dx, ny=y+dy;
    if(nx>0&&ny>0&&nx<GRID-1&&ny<GRID-1&&maze[ny][nx]){
      maze[y+dy/2][x+dx/2]=0;
      carve(nx,ny);
    }
  });
}
carve(1,1);

/* ================= WALLS ================= */
const wallGeo = new THREE.BoxGeometry(CELL, WALL_H, CELL);
const wallMat = new THREE.MeshStandardMaterial({color:0x555555});

for(let z=0;z<GRID;z++){
  for(let x=0;x<GRID;x++){
    if(maze[z][x]){
      const w=new THREE.Mesh(wallGeo,wallMat);
      w.position.set((x-GRID/2)*CELL,WALL_H/2,(z-GRID/2)*CELL);
      scene.add(w);
    }
  }
}

/* ================= FLOOR ================= */
const floor=new THREE.Mesh(
  new THREE.PlaneGeometry(1000,1000),
  new THREE.MeshStandardMaterial({color:0x222222})
);
floor.rotation.x=-Math.PI/2;
scene.add(floor);

/* ================= HELPERS ================= */
function gridToWorld(g){
  return (g-GRID/2)*CELL;
}
function worldToGrid(v){
  return Math.round(v/CELL+GRID/2);
}
function openCell(x,z){
  return maze[z]?.[x]===0;
}
function randomOpen(){
  while(true){
    const x=Math.floor(Math.random()*GRID);
    const z=Math.floor(Math.random()*GRID);
    if(openCell(x,z)) return {x,z};
  }
}

/* ================= PLAYER ================= */
const player = {
  pos:new THREE.Vector3(),
  yaw:0
};
const ps = randomOpen();
player.pos.set(gridToWorld(ps.x),1.7,gridToWorld(ps.z));

/* ================= ENEMY ================= */
const enemyMesh = new THREE.Mesh(
  new THREE.BoxGeometry(2,2,2),
  new THREE.MeshStandardMaterial({color:0xff4444})
);
scene.add(enemyMesh);

const es = randomOpen();
let enemy = {
  gx: es.x,
  gz: es.z,
  tx: es.x,
  tz: es.z,
  mode: "ROAM",
  cooldown: 0
};
enemyMesh.position.set(gridToWorld(enemy.gx),1,gridToWorld(enemy.gz));

/* ================= INPUT ================= */
const keys={};
addEventListener('keydown',e=>keys[e.key.toLowerCase()]=true);
addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);
addEventListener('mousemove',e=>player.yaw-=e.movementX*0.002);
document.body.addEventListener('click',()=>document.body.requestPointerLock());

/* ================= AI ================= */
function neighbors(x,z){
  return [
    [x+1,z],[x-1,z],[x,z+1],[x,z-1]
  ].filter(([a,b])=>openCell(a,b));
}

function chooseRoamTarget(){
  const n = neighbors(enemy.gx,enemy.gz);
  if(n.length){
    const [x,z]=n[Math.floor(Math.random()*n.length)];
    enemy.tx=x; enemy.tz=z;
  }
}

/* ================= LOOP ================= */
const pSpeed=0.18;
const eSpeed=0.08;
const fill=document.getElementById("fill");

function animate(){
  requestAnimationFrame(animate);

  /* ===== Player ===== */
  let dx=0,dz=0;
  if(keys.w) dz-=pSpeed;
  if(keys.s) dz+=pSpeed;
  if(keys.a) dx-=pSpeed;
  if(keys.d) dx+=pSpeed;

  const sin=Math.sin(player.yaw);
  const cos=Math.cos(player.yaw);
  player.pos.x+=dx*cos-dz*sin;
  player.pos.z+=dz*cos+dx*sin;

  /* ===== Enemy AI ===== */
  const pxg = worldToGrid(player.pos.x);
  const pzg = worldToGrid(player.pos.z);

  const dist = Math.hypot(pxg-enemy.gx,pzg-enemy.gz);

  enemy.mode = dist < 6 ? "CHASE" : "ROAM";

  if(enemy.cooldown<=0){
    if(enemy.mode==="CHASE"){
      const opts = neighbors(enemy.gx,enemy.gz)
        .sort((a,b)=>Math.hypot(pxg-a[0],pzg-a[1]) - Math.hypot(pxg-b[0],pzg-b[1]));
      if(opts[0]) [enemy.tx,enemy.tz]=opts[0];
    } else chooseRoamTarget();
    enemy.cooldown=30;
  }
  enemy.cooldown--;

  enemy.gx += Math.sign(enemy.tx-enemy.gx)*eSpeed;
  enemy.gz += Math.sign(enemy.tz-enemy.gz)*eSpeed;

  enemyMesh.position.x = gridToWorld(enemy.gx);
  enemyMesh.position.z = gridToWorld(enemy.gz);

  /* ===== Meter ===== */
  const danger=Math.max(0,1-dist/10);
  fill.style.width=`${danger*100}%`;
  fill.style.background=danger>0.7?"red":danger>0.4?"orange":"lime";

  /* ===== Camera POV ===== */
  camera.position.copy(player.pos);
  camera.rotation.set(0,player.yaw,0);

  renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
