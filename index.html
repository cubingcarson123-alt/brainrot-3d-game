<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Maze Fixed</title>
<style>
  body { margin: 0; overflow: hidden; background: black; }
  #hint {
    position: fixed;
    top: 10px;
    width: 100%;
    text-align: center;
    color: white;
    font-family: monospace;
    opacity: 0.8;
    z-index: 10;
  }
</style>
</head>
<body>
<div id="hint">Click to lock mouse â€¢ Hold W to move</div>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

<script>
/* ===== SCENE ===== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(
  75, innerWidth / innerHeight, 0.1, 1000
);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ===== LIGHT ===== */
scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const light = new THREE.PointLight(0xffffff, 0.8);
light.position.set(0, 20, 0);
scene.add(light);

/* ===== PLAYER ===== */
const player = {
  speed: 0.12,
  yaw: 0,
  pitch: 0
};

/* SPAWN POINT (SAFE, CENTER OF PATH) */
camera.position.set(2, 1.6, 2);

/* ===== POINTER LOCK ===== */
renderer.domElement.addEventListener("click", () => {
  renderer.domElement.requestPointerLock();
});

document.addEventListener("mousemove", e => {
  if (document.pointerLockElement !== renderer.domElement) return;

  player.yaw -= e.movementX * 0.002;
  player.pitch -= e.movementY * 0.002;
  player.pitch = Math.max(-1.5, Math.min(1.5, player.pitch));

  camera.rotation.set(player.pitch, player.yaw, 0);
});

/* ===== INPUT ===== */
let forward = false;
document.addEventListener("keydown", e => {
  if (e.code === "KeyW") forward = true;
});
document.addEventListener("keyup", e => {
  if (e.code === "KeyW") forward = false;
});

/* ===== MAZE ===== */
const maze = [
  "1111111111",
  "1000000001",
  "1011111101",
  "1010000101",
  "1010110101",
  "1000000001",
  "1111111111"
];

const WALL = 2;
const wallGeo = new THREE.BoxGeometry(WALL, 2, WALL);
const wallMat = new THREE.MeshStandardMaterial({ color: 0x333333 });

const walls = [];

for (let z = 0; z < maze.length; z++) {
  for (let x = 0; x < maze[z].length; x++) {
    if (maze[z][x] === "1") {
      const w = new THREE.Mesh(wallGeo, wallMat);
      w.position.set(x * WALL, 1, z * WALL);
      scene.add(w);
      walls.push(w);
    }
  }
}

/* ===== FLOOR ===== */
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(100, 100),
  new THREE.MeshStandardMaterial({ color: 0x111111 })
);
floor.rotation.x = -Math.PI / 2;
scene.add(floor);

/* ===== COLLISION ===== */
function collides(pos) {
  for (const w of walls) {
    if (
      Math.abs(pos.x - w.position.x) < 1 &&
      Math.abs(pos.z - w.position.z) < 1
    ) return true;
  }
  return false;
}

/* ===== LOOP ===== */
function animate() {
  requestAnimationFrame(animate);

  if (forward) {
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    dir.y = 0;
    dir.normalize();

    const next = camera.position.clone().add(dir.multiplyScalar(player.speed));
    if (!collides(next)) camera.position.copy(next);
  }

  renderer.render(scene, camera);
}
animate();

/* ===== RESIZE ===== */
window.addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
