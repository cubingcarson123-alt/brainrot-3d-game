<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Brainrot Maze FIXED</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body{margin:0;overflow:hidden;background:black}
#meter{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);width:300px;height:14px;border:2px solid white}
#fill{height:100%;width:0%;background:red}
</style>
</head>
<body>

<div id="meter"><div id="fill"></div></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
/* ===== SETUP ===== */
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x111111);

const camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,1000);
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});

scene.add(new THREE.AmbientLight(0xffffff,0.7));
const light=new THREE.DirectionalLight(0xffffff,0.6);
light.position.set(10,20,10);
scene.add(light);

/* ===== MAZE ===== */
const GRID=25;
const CELL=8;
const maze=Array.from({length:GRID},()=>Array(GRID).fill(1));

function carve(x,y){
  maze[y][x]=0;
  [[2,0],[-2,0],[0,2],[0,-2]].sort(()=>Math.random()-0.5)
  .forEach(([dx,dy])=>{
    const nx=x+dx, ny=y+dy;
    if(nx>0&&ny>0&&nx<GRID-1&&ny<GRID-1&&maze[ny][nx]){
      maze[y+dy/2][x+dx/2]=0;
      carve(nx,ny);
    }
  });
}
carve(1,1);

const wallGeo=new THREE.BoxGeometry(CELL,6,CELL);
const wallMat=new THREE.MeshStandardMaterial({color:0x555555});
for(let z=0;z<GRID;z++){
  for(let x=0;x<GRID;x++){
    if(maze[z][x]){
      const w=new THREE.Mesh(wallGeo,wallMat);
      w.position.set((x-GRID/2)*CELL,3,(z-GRID/2)*CELL);
      scene.add(w);
    }
  }
}

const floor=new THREE.Mesh(
  new THREE.PlaneGeometry(1000,1000),
  new THREE.MeshStandardMaterial({color:0x222222})
);
floor.rotation.x=-Math.PI/2;
scene.add(floor);

/* ===== SAFE SPAWN ===== */
function findOpenCell(){
  for(let z=0;z<GRID;z++){
    for(let x=0;x<GRID;x++){
      if(maze[z][x]===0){
        return {
          x:(x-GRID/2)*CELL,
          z:(z-GRID/2)*CELL
        };
      }
    }
  }
}
const spawn=findOpenCell();

/* ===== PLAYER ===== */
const player=new THREE.Object3D();
player.position.set(spawn.x,0,spawn.z);
scene.add(player);

const R=1.4;
function blocked(x,z){
  const pts=[[x+R,z],[x-R,z],[x,z+R],[x,z-R]];
  for(const[pX,pZ]of pts){
    const gx=Math.floor(pX/CELL+GRID/2);
    const gz=Math.floor(pZ/CELL+GRID/2);
    if(maze[gz]?.[gx]===1) return true;
  }
  return false;
}

/* ===== ENEMY ===== */
const enemy=new THREE.Mesh(
  new THREE.BoxGeometry(3,3,3),
  new THREE.MeshStandardMaterial({color:0xff3333})
);
enemy.position.set(spawn.x+CELL*4,1.5,spawn.z+CELL*4);
scene.add(enemy);

/* ===== INPUT ===== */
const keys={};
addEventListener('keydown',e=>keys[e.key.toLowerCase()]=true);
addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);

renderer.domElement.addEventListener('click',()=>{
  renderer.domElement.requestPointerLock();
});

let yaw=0;
addEventListener('mousemove',e=>{
  if(document.pointerLockElement){
    yaw-=e.movementX*0.002;
  }
});

/* ===== LOOP ===== */
function loop(){
  requestAnimationFrame(loop);

  const dir=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
  if(keys.w){
    const nx=player.position.x+dir.x*0.18;
    const nz=player.position.z+dir.z*0.18;
    if(!blocked(nx,nz)){
      player.position.x=nx;
      player.position.z=nz;
    }
  }

  camera.position.set(player.position.x,1.7,player.position.z);
  camera.lookAt(player.position.x+dir.x,1.7,player.position.z+dir.z);

  const dx=player.position.x-enemy.position.x;
  const dz=player.position.z-enemy.position.z;
  const d=Math.hypot(dx,dz)||1;
  const ex=enemy.position.x+dx/d*0.1;
  const ez=enemy.position.z+dz/d*0.1;
  if(!blocked(ex,ez)){
    enemy.position.x=ex;
    enemy.position.z=ez;
  }

  document.getElementById("fill").style.width=
    ((40-Math.min(40,d))/40*100)+"%";

  renderer.render(scene,camera);
}
loop();
</script>
</body>
</html>
