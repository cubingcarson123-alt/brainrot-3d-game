<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>BIG MAZE FINAL</title>
<style>
body{margin:0;overflow:hidden;background:#000}
#ui{
 position:fixed;bottom:20px;left:50%;
 transform:translateX(-50%);
 width:300px;height:20px;
 border:2px solid #fff
}
#bar{
 height:100%;width:0%;
 background:lime;
 transition:width 0.1s, background 0.2s;
}
#map{
 position:fixed;top:10px;right:10px;
 width:220px;height:220px;
 border:2px solid #fff;background:#111
}
</style>
</head>
<body>

<div id="ui"><div id="bar"></div></div>
<canvas id="map" width="220" height="220"></canvas>

<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>
<script>
/* ===== SCENE ===== */
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x111);

const camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,2000);
camera.position.set(0,1.6,200);

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

/* ===== LIGHT ===== */
scene.add(new THREE.AmbientLight(0xffffff,1));

/* ===== FLOOR ===== */
const floor=new THREE.Mesh(
 new THREE.PlaneGeometry(800,800),
 new THREE.MeshBasicMaterial({color:0x222})
);
floor.rotation.x=-Math.PI/2;
scene.add(floor);

/* ===== MAZE ===== */
const walls=[];
function wall(x,z,w,d){
 const m=new THREE.Mesh(
  new THREE.BoxGeometry(w,5,d),
  new THREE.MeshBasicMaterial({color:0x4aa3ff})
 );
 m.position.set(x,2.5,z);
 m.userData={w,d};
 scene.add(m); walls.push(m);
}

/* outer */
for(let i=-380;i<=380;i+=40){
 wall(i,-380,40,4); wall(i,380,40,4);
}
for(let i=-340;i<=340;i+=80){
 wall(-380,i,4,80); wall(380,i,4,80);
}

/* inner grid */
for(let i=-300;i<=300;i+=120){
 wall(i,0,4,600);
 wall(0,i,600,4);
 wall(i,200,200,4);
 wall(200,i,4,200);
}

/* ===== COLLISION ===== */
function hit(p,r=0.7){
 for(const w of walls){
  if(Math.abs(p.x-w.position.x)<w.userData.w/2+r &&
     Math.abs(p.z-w.position.z)<w.userData.d/2+r) return true;
 }
 return false;
}

/* ===== INPUT ===== */
const keys={};
addEventListener("keydown",e=>keys[e.key.toLowerCase()]=true);
addEventListener("keyup",e=>keys[e.key.toLowerCase()]=false);
let yaw=0,vy=0,onGround=true;

/* ===== ENEMY ===== */
const enemy=new THREE.Group();

/* body */
const body=new THREE.Mesh(
 new THREE.BoxGeometry(3,4,2),
 new THREE.MeshBasicMaterial({color:0xffffff})
);
body.position.y=4;
enemy.add(body);

/* face */
function face(){
 const c=document.createElement("canvas");
 c.width=c.height=128;
 const g=c.getContext("2d");
 g.fillStyle="#fff"; g.fillRect(0,0,128,128);
 g.fillStyle="#000";
 g.beginPath(); g.arc(40,50,8,0,6.28); g.arc(88,50,8,0,6.28); g.fill();
 g.beginPath(); g.arc(64,78,22,0,Math.PI); g.stroke();
 return new THREE.CanvasTexture(c);
}
const faceMesh=new THREE.Mesh(
 new THREE.PlaneGeometry(2.8,3),
 new THREE.MeshBasicMaterial({map:face(),transparent:true})
);
faceMesh.position.z=1.01;
faceMesh.position.y=4;
enemy.add(faceMesh);

/* legs */
const legMat=new THREE.MeshBasicMaterial({color:0xaaaaaa});
const leg1=new THREE.Mesh(new THREE.BoxGeometry(0.8,2,0.8),legMat);
const leg2=leg1.clone();
leg1.position.set(-0.8,1,0);
leg2.position.set(0.8,1,0);
enemy.add(leg1,leg2);

enemy.position.set(300,0,300);
scene.add(enemy);

let roamDir=new THREE.Vector3(1,0,0);

/* ===== UI ===== */
const bar=document.getElementById("bar");
const map=document.getElementById("map").getContext("2d");
const SCALE=0.25;

/* ===== LOOP ===== */
function animate(){
 requestAnimationFrame(animate);

 /* LOOK */
 if(keys.arrowleft) yaw+=0.04;
 if(keys.arrowright) yaw-=0.04;
 camera.rotation.y=yaw;

 /* MOVE */
 let v=new THREE.Vector3();
 if(keys.w) v.z-=1;
 if(keys.s) v.z+=1;
 if(keys.a) v.x-=1;
 if(keys.d) v.x+=1;

 if(v.length()){
  v.normalize().applyAxisAngle(new THREE.Vector3(0,1,0),yaw);
  const n=camera.position.clone().add(v.multiplyScalar(0.35));
  if(!hit(n)) camera.position.copy(n);
 }

 /* JUMP */
 if(keys[" "]&&onGround){vy=0.28;onGround=false;}
 vy-=0.018;
 camera.position.y+=vy;
 if(camera.position.y<=1.6){
  camera.position.y=1.6;vy=0;onGround=true;
 }

 /* ENEMY AI */
 const toP=camera.position.clone().sub(enemy.position);
 const dist=toP.length();
 let move=dist<120?toP:roamDir;
 move.y=0; move.normalize();

 const en=enemy.position.clone().add(move.multiplyScalar(dist<120?0.22:0.08));
 if(hit(en)){
  roamDir.applyAxisAngle(new THREE.Vector3(0,1,0),Math.PI/2);
 }else enemy.position.copy(en);

 enemy.lookAt(camera.position);
 faceMesh.lookAt(camera.position);

 /* PROXIMITY BAR */
 let pct=Math.max(0,1-dist/150);
 bar.style.width=(pct*100)+"%";
 bar.style.background=pct>0.7?"red":pct>0.4?"orange":"lime";

 /* MAP */
 map.clearRect(0,0,220,220);
 map.fillStyle="#222"; map.fillRect(0,0,220,220);
 map.fillStyle="#555";
 for(const w of walls){
  map.fillRect(
   w.position.x*SCALE+110,
   w.position.z*SCALE+110,
   w.userData.w*SCALE,
   w.userData.d*SCALE
  );
 }
 map.fillStyle="#0f0";
 map.fillRect(camera.position.x*SCALE+110,camera.position.z*SCALE+110,4,4);
 map.fillStyle="#f00";
 map.fillRect(enemy.position.x*SCALE+110,enemy.position.z*SCALE+110,4,4);

 renderer.render(scene,camera);
}
animate();

onresize=()=>{
 camera.aspect=innerWidth/innerHeight;
 camera.updateProjectionMatrix();
 renderer.setSize(innerWidth,innerHeight);
};
</script>
</body>
</html>
